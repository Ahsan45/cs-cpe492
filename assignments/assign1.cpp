#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <time.h>

//Global Variables (These probably don't need to be global)
int NUMP, NUMC, TOTP, QSIZE, ALGO, QUANTUM, SEED;

class Product{
    private:
        int id;
        int timestamp;
        int life;

    public:
        Product(int id, clock_t timestamp, int seed){
            this->id = id;
            this->timestamp = timestamp;
            srandom(seed);
            this->life = random() % 1024;
        }
};

void *producer(void *id){
    int v = *(int*)id;
    pthread_exit(NULL);
}

void *consumer(void *id){
    int v = *(int*)id;
    pthread_exit(NULL);
}

// • NUMP: Number of producer threads
// • NUMC: Number of consumer threads
// • NUMPT: Total number of products to be generated by all producer threads
// • Q_SIZE: Size of the queue to store products for both producer and consumer threads (0 for
// unlimited queue size)
// • ALGO: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for
// Round-Robin
// • QUANTUM: Value of quantum used for round-robin scheduling.
// • SEED: Seed for random number generator 

int main(int argc, char* argv[]){
    // for (int i = 0; i < argc; ++i)
    //     std::cout << argv[i] << "\n";
    NUMP = atoi(argv[1]);
    NUMC = atoi(argv[2]);
    TOTP = atoi(argv[3]);
    QSIZE = atoi(argv[4]);
    ALGO = atoi(argv[5]);
    QUANTUM = atoi(argv[6]);
    SEED = atoi(argv[7]);

    clock_t timestamp;
    timestamp = clock();
    
    // Create prod threads

    int i;     

    pthread_t prod_thread[NUMP];
    int prodID[NUMP];

    for (i=0;i<NUMP;i++){
        prodID[i] = i;
        pthread_create(&prod_thread[i], NULL, producer, &prodID[i]);
    }

    // initialize/join prod threads

    for (i=0;i<NUMP;i++)
        pthread_join(prod_thread[i],NULL);

    // create consumer threads

    pthread_t consmr_thread[NUMC];
    int consmrID[NUMP];

    for (i=0;i<NUMC;i++){
        consmrID[i] = i;
        pthread_create(&consmr_thread[i], NULL, consumer, &consmrID[i]);
    }

    // join consumer threads

    for (i=0;i<NUMC;i++)
        pthread_join(consmr_thread[i],NULL);

    // delete everything

    pthread_exit(0);

    return 0;
}
